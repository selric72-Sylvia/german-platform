<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>ğŸ“ å•è¯æµ‹è¯•ï¼ˆäº‘åŒæ­¥ï¼‰</title>
<link rel="stylesheet" href="../assets/style.css">

<style>
.card {
  border:1px solid #ccc;
  padding:16px;
  border-radius:12px;
  background:#f8f8f8;
  margin-top:20px;
}
.option {
  padding:8px 12px;
  background:#e5e5e5;
  margin:6px 0;
  border-radius:6px;
  cursor:pointer;
}
.option.correct { background:#a0e7a0; }
.option.wrong { background:#ffb3b3; }
.btn { padding:8px 14px; background:#4f8cff; color:white; border-radius:6px; cursor:pointer; }
</style>
</head>

<body>

<a href="../index.html" class="back">â† è¿”å›é¦–é¡µ</a>
<h2>ğŸ“ å•è¯æµ‹è¯•ï¼ˆäº‘åŒæ­¥ï¼‰</h2>
<p>ç”¨æˆ·IDï¼š<span id="uidShort" style="font-weight:bold"></span></p>

<div>
  <label>æµ‹è¯•é¢˜æ•°ï¼š</label>
  <select id="countSelect">
    <option>5</option>
    <option>10</option>
    <option>15</option>
    <option>20</option>
  </select>

  <label style="margin-left:20px;">æµ‹è¯•æ¨¡å¼ï¼š</label>
  <select id="modeSelect">
    <option value="cn">çœ‹ä¸­æ–‡é€‰å¾·è¯­</option>
    <option value="de">çœ‹å¾·è¯­é€‰ä¸­æ–‡</option>
  </select>

  <button class="btn" id="startBtn">å¼€å§‹æµ‹è¯•</button>
</div>

<div id="testArea" style="display:none;">
  <div class="card">
    <h3 id="questionText"></h3>
    <div id="options"></div>
  </div>
</div>

<div id="resultArea" style="display:none; margin-top:20px;">
  <h3>æµ‹è¯•å®Œæˆï¼</h3>
  <p>æ­£ç¡®ï¼š<span id="correctCount"></span></p>
  <p>é”™è¯¯ï¼š<span id="wrongCount"></span></p>
  <p>æ­£ç¡®ç‡ï¼š<span id="accuracy"></span>%</p>
  <p>é”™è¯¯å•è¯ï¼š</p>
  <ul id="wrongList"></ul>
</div>

<script type="module">
import { autoLogin, onUser, load, save } from "../assets/firebase.js";

// ---- å…¨å±€å˜é‡ ----
let uid = null;
let base = [];
let cloud = [];
let known = [];
let vocab = [];
let questions = [];
let qIndex = 0;
let correct = 0;
let wrongWords = [];

// ---- åŠ è½½ base vocab.json ----
async function loadBase() {
  try {
    const resp = await fetch("../data/vocab.json");
    base = await resp.json();
  } catch {
    base = [];
  }
}

// ---- åˆå¹¶è¯åº“ ----
function merge() {
  const map = new Map();
  base.forEach(w => map.set(w.word, { ...w }));
  cloud.forEach(w => map.set(w.word, { ...map.get(w.word), ...w }));
  vocab = Array.from(map.values());
}

// ---- éšæœºæŠ½å–è‹¥å¹²å•è¯ç”Ÿæˆé¢˜ç›® ----
function generateQuestions(n, mode) {
  const arr = [...vocab].sort(() => Math.random() - 0.5).slice(0, n);
  const qs = [];

  arr.forEach(item => {
    let question, answer, options;

    if (mode === "cn") { 
      question = "é€‰æ‹©æ­£ç¡®çš„å¾·è¯­å•è¯ï¼š " + item.meaning;
      answer = item.word;
      options = arr.slice(0, 4).map(w => w.word);
    } else { 
      question = "é€‰æ‹©æ­£ç¡®çš„ä¸­æ–‡é‡Šä¹‰ï¼š " + item.word;
      answer = item.meaning;
      options = arr.slice(0, 4).map(w => w.meaning);
    }

    // å»é‡å¹¶æ··æ·†é€‰é¡¹
    options = Array.from(new Set(options));
    if (!options.includes(answer)) options[0] = answer;
    options = options.sort(() => Math.random() - 0.5);

    qs.push({
      question,
      answer,
      options,
      source: item
    });
  });

  return qs;
}

// ---- æ˜¾ç¤ºé¢˜ç›® ----
function showQuestion() {
  const q = questions[qIndex];
  questionText.innerText = `(${qIndex+1}/${questions.length}) ` + q.question;

  const box = document.getElementById("options");
  box.innerHTML = "";

  q.options.forEach(opt => {
    const div = document.createElement("div");
    div.className = "option";
    div.textContent = opt;

    div.onclick = () => {
      if (opt === q.answer) {
        div.classList.add("correct");
        correct++;
      } else {
        div.classList.add("wrong");
        wrongWords.push(q.source.word + " â€” " + q.source.meaning);
      }

      setTimeout(() => {
        qIndex++;
        if (qIndex >= questions.length) {
          showResult();
        } else {
          showQuestion();
        }
      }, 600);
    };

    box.appendChild(div);
  });
}

// ---- æ˜¾ç¤ºç»“æœ ----
async function showResult() {
  testArea.style.display = "none";
  resultArea.style.display = "block";

  correctCount.innerText = correct;
  wrongCount.innerText = questions.length - correct;
  accuracy.innerText = Math.round(correct / questions.length * 100);

  wrongList.innerHTML = "";
  wrongWords.forEach(w => {
    const li = document.createElement("li");
    li.textContent = w;
    wrongList.appendChild(li);
  });

  // ---- å†™å…¥äº‘ç«¯ testRecords ----
  await save("testRecords", uid, {
    [Date.now()]: {
      total: questions.length,
      correct: correct,
      wrong: wrongWords,
      accuracy: Math.round(correct / questions.length * 100),
      date: new Date().toLocaleString()
    }
  });

  alert("æµ‹è¯•è®°å½•å·²åŒæ­¥åˆ°äº‘ç«¯ï¼");
}

// ---- ç‚¹å‡»å¼€å§‹æµ‹è¯• ----
startBtn.onclick = () => {
  const count = parseInt(countSelect.value);
  const mode = modeSelect.value;

  if (vocab.length === 0) return alert("è¯åº“ä¸ºç©ºï¼Œæ— æ³•æµ‹è¯•");

  questions = generateQuestions(count, mode);
  qIndex = 0;
  correct = 0;
  wrongWords = [];

  resultArea.style.display = "none";
  testArea.style.display = "block";

  showQuestion();
};

// ---- è‡ªåŠ¨åŒ¿åç™»å½• ----
autoLogin();

// ---- åŠ è½½äº‘ç«¯è¯åº“ ----
onUser(async (user) => {
  if (!user) return;

  uid = user.uid;
  uidShort.innerText = uid.slice(0, 6);

  await loadBase();

  const data = await load("vocab", uid);
  cloud = data.words || [];
  known = data.known || [];

  merge();
});
</script>

</body>
</html>
